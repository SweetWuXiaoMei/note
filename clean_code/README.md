# 代码简洁之道

### 第7章 异常
-  表明方法错误时，不要使用code，而是使用异常
- 使用try...catch...finally...
- 尽量使用非检测异常（继承RuntimeException），可将检测异常转化为非检测异常（继承Exception），
   因为检测异常会破坏开闭原则，如果底层方法抛出异常，那么上层处理的每个方法都需要抛出异常
- 封装异常，见代码chapter7
- 将发生异常时的信息，尽量多的保留下来，便于发生排查错误
- 不用返回null，通过返回空对象或者抛出异常的方式
- 任何时候都不要传递null参数

### 第8章 边界
- 在使用第三方api时， 应该将它封装起来，例如在引入fastjson解析的包，可以使用自己定义JsonUtil，
   这样如将fastjson替换为jackson时，只需要替换Jsonutil即可
```
// 错误示例：
Map map = new HashMap();
Sensor sensor = map.get("sensorId");

// 正确示例：
public class Sensors {
    private Map map;
    
    public Sensor getSensor(String str) {
        return map.get("sensorId");
    }
}
```
- 在调用第三方代码时，第三方的定义还未定义出来时，可将api信息自己封装成一个接口，待第三方api完成后，在定义
   适配器适配，可使用设计模式(适配器模式)
- 当使用第三方api时，可学习性测试，即另起一个小项目，进行对api的了解和测试
- 要善于封装第三方的服务，使用适配器模式或者另外封装成一个类

### 第9章 单元测试
- 测试代码应该和生产代码一样简洁
- 测试代码应该尽量保证一个断言语句
- 测试代码不应该依靠另外一个测试代码
- 测试代码应该可重复执行


### 第10章 类
- 类应该短小，单一职责(只做一件事)，且命名要描述清楚意思，不建议使用processor，manager，super等单词，
   因为这种单词意味着一个，类有多个职责，类只有一个修改的理由
- 系统应该由许多短小的类组成，而不是由少量的巨大的类组成，每个小类封装一个权责，只有一个修改的理由，
   并与少量其他类一起协同达成期望的系统行为，类的只有一个修改理由是指，类应该只有一个功能，并修改这个
   功能，示例如下：
```
/**
 * 升级组件必然升级版本号，升级版本号，未必是升级组件，可能是修改别的内容，这是做了两件事情 
 */
public class MultipleFuctionClass {

    // 功能1，升级组件
    public void updateComponent(){...}
    
    // 功能2，升级版本号
    public void updateVersion(){...}
    
    // 获取版本号
    public void getVersion(){...}
}

/**
 * 分成两个类，一个是只更新版本号，另外一个只更新组件 
 */
public class VersionClass {

    // 功能1，升级版本号
    public void updateVersion(){...}
    
    // 获取版本号
    public void getVersion(){...}
}

public class ComponentClass {

    // 功能1，升级组件
    public void updateComponent(){...}
}
```
- 类应该保持最大的内聚，关于内聚的定义：
```
类中的每个方法都应该操作一个或者多个变量，通常，方法操作的变量越多，越会内聚到类上，如果一个类中的每个变量都
被每个方法所使用，则称该类具有最大的内聚性
```
- 保持内聚会得到许多的短小的类，过程如下
```
一个大的方法=>将方法内的一部分提升为方法=>为了避免原来的大方法中的变量变成新函数的参数，、
可以原方法的变量提升为类的成员变量，消除传参问题=>但是这样破坏了内聚性，因为堆积了许多为了少量函数共享而存在的变量
=>将这些成员变量封装为类
这个过程也说明了，重构是一步一步的，是不能一蹴而就的
```
- 隔离修改，多使用具有单一职责的抽象
