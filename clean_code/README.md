# 代码简洁之道

### 第7章 异常
- 表明方法错误时，不要使用code，而是使用异常
- 使用try...catch...finally...
- 尽量使用非检测异常（继承RuntimeException），可将检测异常转化为非检测异常（继承Exception），
  因为检测异常会破坏开闭原则，如果底层方法抛出异常，那么上层处理的每个方法都需要抛出异常
- 封装异常，见代码chapter7
- 将发生异常时的信息，尽量多的保留下来，便于发生排查错误
- 不用返回null，通过返回空对象或者抛出异常的方式
- 任何时候都不要传递null参数

### 第8章 边界
- 在使用第三方api时，应该将它封装起来，例如在引入fastjson解析的包，可以使用自己定义JsonUtil，
  这样如将fastjson替换为jackson时，只需要替换Jsonutil即可
  ```
  // 错误示例：
  Map map = new HashMap();
  Sensor sensor = map.get("sensorId");
  
  // 正确示例：
  public class Sensors {
      private Map map;
      
      public Sensor getSensor(String str) {
          return map.get("sensorId");
      }
  }
  ```
- 在调用第三方代码时，第三方的定义还未定义出来时，可将api信息自己封装成一个接口，待第三方api完成后，在定义
   适配器适配，可使用设计模式(适配器模式)
- 当使用第三方api时，可学习性测试，即另起一个小项目，进行对api的了解和测试
- 要善于封装第三方的服务，使用适配器模式或者另外封装成一个类

### 第9章 单元测试
- 测试代码应该和生产代码一样简洁
- 测试代码应该尽量保证一个断言语句
- 测试代码不应该依靠另外一个测试代码
- 测试代码应该可重复执行


### 第10章 类
- 类应该短小，单一职责(只做一件事)，且命名要描述清楚意思，不建议使用processor，manager，super等单词，
   因为这种单词意味着一个，类有多个职责，类只有一个修改的理由
- 系统应该由许多短小的类组成，而不是由少量的巨大的类组成，每个小类封装一个权责，只有一个修改的理由，
   并与少量其他类一起协同达成期望的系统行为，类的只有一个修改理由是指，类应该只有一个功能，并修改这个
   功能，示例如下：
    ```
    /**
     * 升级组件必然升级版本号，升级版本号，未必是升级组件，可能是修改别的内容，这是做了两件事情 
     */
    public class MultipleFuctionClass {
    
        // 功能1，升级组件
        public void updateComponent(){...}
        
        // 功能2，升级版本号
        public void updateVersion(){...}
        
        // 获取版本号
        public void getVersion(){...}
    }
    
    /**
     * 分成两个类，一个是只更新版本号，另外一个只更新组件 
     */
    public class VersionClass {
    
        // 功能1，升级版本号
        public void updateVersion(){...}
        
        // 获取版本号
        public void getVersion(){...}
    }
    
    public class ComponentClass {
    
        // 功能1，升级组件
        public void updateComponent(){...}
    }
    ```
- 类应该保持最大的内聚，关于内聚的定义：
```
类中的每个方法都应该操作一个或者多个变量，通常，方法操作的变量越多，越会内聚到类上，如果一个类中的每个变量都
被每个方法所使用，则称该类具有最大的内聚性
```
- 保持内聚会得到许多的短小的类，过程如下
```
一个大的方法=>将方法内的一部分提升为方法=>为了避免原来的大方法中的变量变成新函数的参数，、
可以原方法的变量提升为类的成员变量，消除传参问题=>但是这样破坏了内聚性，因为堆积了许多为了少量函数共享而存在的变量
=>将这些成员变量封装为类
这个过程也说明了，重构是一步一步的，是不能一蹴而就的
```
- 隔离修改，多使用具有单一职责的抽象

### 第11章 系统
- 类中的成员变量，不应该由类自己构建，而是通过调用方构造好了之后，在传递进去
- 将系统模块化，让模块只关注自己的内容

### 第12章 迭进
保持设计整洁的四个准则
1. 运行所有的测试，使测试难度更低，可以促使遵循DIP(单一职责)准则
2. 不可重复，消除重复，在《从小工到专家》一书中也提到，显示重复时简洁的天地
3. 使用更加有表达力的类名或者方法名
4. 尽可能的减少类和方法的数量，这个准备看起来和上述准则矛盾，其目的是为了避免过度设计，
5. 第4条准则是重要性比较低的准则，更加重要的是易于测试，消除重复，有意义的表达

### 第13章 并发
- 单一职责，方法/类/组件应当值拥有一个修改的理由，并发代码应该拥有自己ide开发，修改的生命周期
- 限制数据的作用域
- 复制数据副本
- 每个线程尽可能的独立
- 生产者消费者模型，读者-写者模型，哲学家模型
- 避免使用共享对象的多个方法
    ```
    共享对象(服务端对象)ShareDataClass，客户端对象ClientClass，ShareDataClass中有多个方法
    当客户端对象ClientClass多线程调用共享对象ShareDataClass的多个方法时，有以下几种手段保证
    1. 基于客户端对象锁定客户端对象ClientClass：客户端代码在调用第一个方法前锁定代码，确保锁的
    范围覆盖了共享对象的最后一个方法，例如，自己使用synchronized
    2. 基于服务器端的锁定：在服务端内创建锁定服务端的方法，调用所有方法，然后解锁，例如
    使用StringBuffer，每个方法都是synchronized
    3. 适配服务端：创建执行锁定的中间层，这是一种基于服务端锁定的例子，但是不修改原始服务器端代码
    可使服务器端代码并发安全
    ```
- 尽量减少同步区域的大小
- 写试错代码，增加Object.waite()，Object.sleep()，Object.yield()，Object.priority()
  的调用，这些方法会影响执行顺序，从而更加可能的测试出并发代码的错误
  ```
  1. 硬编码，在下面的例子中，Thread.yield()方法是线程停止，这样使得程序发生了暂停，改变了cpu的执行的顺序
     public synchronized String functionName() {
       xxx
       Thread.yield();
       xxxx 
     }
  2. 自动化，新建一个类，在这个类中随机填充sleep，yield等方法，改变线程执行顺序， 在生产环境中是空的
     或者，使用其他工具无侵入的填充代码进去
    public class ThreadJigglePoint{
       public static void jiggle() {
       }
    }
    public synchronized String functionName() {
       xxx
       ThreadJigglePoint.jiggle();
       xxxx 
    }
  ```
### 第14章 逐步改进


### 第15章 Junit内幕

